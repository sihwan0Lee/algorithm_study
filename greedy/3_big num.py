# 큰 수의 법칙
# 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
# 배열의 특정 인덱스에 해당하는 수는 연속해서 K 번을 초과할 순 없다.
# N : 배열 크기,  M : 더해지는 횟수, K : 초과할수 없는 횟수

n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n - 1]  # 가장 큰 수
second = data[n - 2]  # 두번째로 큰 수

result = 0

while True:
    for i in range(k):   # 한 동전은 k번 만큼만 중복 가능하므로.
        if m == 0:         # 더해질수있는 횟수가 0이 되면 그만.
            break
        result += first  # 그렇지 않은 동안 계속 더해간다.
        m -= 1
    if m == 0:
        break
    result += second
    m -= 1

print(result)

# 한번에 중복되는 횟수만 제한이 있으므로 결국 sort로 오름차순으로 만든다음 첫번쨰로 큰수와 두번째로 큰수만 알면된다.
# 그리고 가장 큰수만 최대한 많이 나오는것이 중요하고 가장 큰수가 중복되다가 횟수가 초과되면 두번째로 큰수를 넣어준다고 생각하면된다.
# 그리고 break가 for반복문의 명령이 나오기전에 나오는 이유는 사실 간단한 이유인데,
# 더이상 횟수가 없는데 한번 반복 수행을 하고 나서야 break를하면 원래 수행했어야할 횟수보다 1회 더하게 되기 때문이다.
